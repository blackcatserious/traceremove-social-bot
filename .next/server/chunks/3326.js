"use strict";exports.id=3326,exports.ids=[3326],exports.modules={83326:(e,s,t)=>{t.d(s,{gm:()=>O});var r,a,n,c=class extends Error{constructor(e){super(e),this.name="UpstashError"}},i=class{constructor(e){this.options={cache:e.cache,signal:e.signal},this.baseUrl=e.baseUrl.replace(/\/$/,""),this.headers={"Content-Type":"application/json",...e.headers},this.retry="boolean"==typeof e?.retry&&e?.retry===!1?{attempts:1,backoff:()=>0}:{attempts:e?.retry?.retries??5,backoff:e?.retry?.backoff??(e=>50*Math.exp(e))}}async request(e){let s=this.options.signal,t="function"==typeof s,r={cache:this.options.cache,method:"POST",headers:this.headers,body:JSON.stringify(e.body),keepalive:!0,signal:t?s():s},a=null,n=null;for(let s=0;s<=this.retry.attempts;s++)try{a=await fetch([this.baseUrl,...e.path??[]].join("/"),r);break}catch(e){if(r.signal?.aborted&&t)throw e;if(r.signal?.aborted){let e=new Blob([JSON.stringify({result:r.signal.reason??"Aborted"})]),s={status:200,statusText:r.signal.reason??"Aborted"};a=new Response(e,s);break}n=e,s<this.retry.attempts&&await new Promise(e=>setTimeout(e,this.retry.backoff(s)))}if(!a)throw n??Error("Exhausted all retries");let i=await a.json();if(!a.ok)throw new c(`${i.error}`);return{result:i.result,error:i.error}}},o=((r=o||{}).IDF="IDF",r),l=((a=l||{}).RRF="RRF",a.DBSF="DBSF",a),h=((n=h||{}).HYBRID="HYBRID",n.DENSE="DENSE",n.SPARSE="SPARSE",n),u=class{constructor(e,s){this.payload=e,this.endpoint=s}async exec(e){let{result:s,error:t}=await e.request({body:this.payload,path:[this.endpoint]});if(t)throw new c(t);if(void 0===s)throw TypeError("Request did not return a result");return s}},p=class extends u{constructor(e,s){let t="query",r=e.some(e=>e.data);t=r?"query-data":"query",s?.namespace&&(t=`${t}/${s.namespace}`),super(e,t)}},d=class extends u{constructor(e,s){let t="query";if("data"in e)t="query-data";else if(!e.vector&&!e.sparseVector)throw new c("Either data, vector or sparseVector should be provided.");s?.namespace&&(t=`${t}/${s.namespace}`),super(e,t)}},m=class extends u{constructor(e,s){let t="delete";s?.namespace&&(t=`${t}/${s.namespace}`),"string"==typeof e||"number"==typeof e?super({ids:[e]},t):Array.isArray(e)?super({ids:e},t):"object"==typeof e&&super(e,t)}},y=class extends u{constructor(e,s){let t="upsert";if(Array.isArray(e)){let s=e.some(e=>w(e));t=s?"upsert":"upsert-data"}else t=w(e)?"upsert":"upsert-data";s?.namespace&&(t=`${t}/${s.namespace}`),super(e,t)}},w=e=>"vector"in e||"sparseVector"in e,E=class extends u{constructor([e,s]){let t="fetch";if(s?.namespace&&(t=`${t}/${s.namespace}`,delete s.namespace),Array.isArray(e))super({ids:e,...s},t);else if("object"==typeof e)super({...e,...s},t);else throw Error("Invalid payload")}},T=class extends u{constructor(e,s){let t="range";s?.namespace&&(t=`${t}/${s.namespace}`),super(e,t)}},S=class extends u{constructor(e){let s="reset";e?.namespace?s=`${s}/${e.namespace}`:e?.all&&(s=`${s}?all`),super([],s)}},f=class extends u{constructor(){super([],"info")}},x=class extends u{constructor(e){super(e,"resumable-query-next")}},R=class extends u{constructor(e,s){let t="resumable-query";"data"in e&&(t="resumable-query-data"),s&&(t=`${t}/${s}`),super(e,t)}},b=class extends u{constructor(e){super(e,"resumable-query-end")}},_=class{constructor(e,s,t){this.start=async()=>{let r=await new R(e,t).exec(s);return this.uuid=r.uuid,r},this.fetchNext=e=>{if(!this.uuid)throw Error("The resumable query has already been stopped. Please start another resumable query.");return new x({uuid:this.uuid,additionalK:e}).exec(s)},this.stop=async()=>{if(!this.uuid)throw Error("Resumable query has not been started. Call start() first.");let e=await new b({uuid:this.uuid}).exec(s);return this.uuid="",e}}},v=class{constructor(e,s){this.upsert=e=>new y(e,{namespace:this.namespace}).exec(this.client),this.update=e=>new U(e,{namespace:this.namespace}).exec(this.client),this.fetch=(...e)=>(e[1]?e[1].namespace=this.namespace:e[1]={namespace:this.namespace},new E(e).exec(this.client)),this.query=e=>new d(e,{namespace:this.namespace}).exec(this.client),this.resumableQuery=async e=>{let s=new _(e,this.client,this.namespace),t=await s.start(),{fetchNext:r,stop:a}=s;return{fetchNext:r,stop:a,result:t.scores}},this.delete=e=>new m(e,{namespace:this.namespace}).exec(this.client),this.range=e=>new T(e,{namespace:this.namespace}).exec(this.client),this.reset=()=>new S({namespace:this.namespace}).exec(this.client),this.client=e,this.namespace=s}},U=class extends u{constructor(e,s){let t="update";s?.namespace&&(t=`${t}/${s.namespace}`),super(e,t)}},A=class extends u{constructor(){super([],"list-namespaces")}},$=class extends u{constructor(e){let s=`delete-namespace/${e}`;super([],s)}},g=class{constructor(e){this.namespace=e=>new v(this.client,e),this.delete=(e,s)=>new m(e,s).exec(this.client),this.query=(e,s)=>new d(e,s).exec(this.client),this.queryMany=(e,s)=>new p(e,s).exec(this.client),this.resumableQuery=async(e,s)=>{let t=new _(e,this.client,s?.namespace),r=await t.start(),{fetchNext:a,stop:n}=t;return{fetchNext:a,stop:n,result:r.scores}},this.upsert=(e,s)=>new y(e,s).exec(this.client),this.update=(e,s)=>new U(e,s).exec(this.client),this.fetch=(...e)=>new E(e).exec(this.client),this.reset=e=>new S(e).exec(this.client),this.range=(e,s)=>new T(e,s).exec(this.client),this.info=()=>new f().exec(this.client),this.listNamespaces=()=>new A().exec(this.client),this.deleteNamespace=e=>new $(e).exec(this.client),this.client=e}},O=class e extends g{constructor(e){if(void 0!==e&&"request"in e){super(e);return}let s=e?.token??process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_TOKEN??process.env.UPSTASH_VECTOR_REST_TOKEN,t=e?.url??process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_URL??process.env.UPSTASH_VECTOR_REST_URL;if(!s)throw Error("UPSTASH_VECTOR_REST_TOKEN is missing!");if(!t)throw Error("UPSTASH_VECTOR_REST_URL is missing!");(t.startsWith(" ")||t.endsWith(" ")||/\r|\n/.test(t))&&console.warn("The vector url contains whitespace or newline, which can cause errors!"),(s.startsWith(" ")||s.endsWith(" ")||/\r|\n/.test(s))&&console.warn("The vector token contains whitespace or newline, which can cause errors!");let r=!process.env.UPSTASH_DISABLE_TELEMETRY&&(e?.enableTelemetry??!0),a=r?{"Upstash-Telemetry-Sdk":"upstash-vector-js@v1.2.2","Upstash-Telemetry-Platform":process.env.VERCEL?"vercel":process.env.AWS_REGION?"aws":"unknown","Upstash-Telemetry-Runtime":"object"==typeof process&&"object"==typeof process.versions&&process.versions.bun?`bun@${process.versions.bun}`:"string"==typeof EdgeRuntime?"edge-light":`node@${process.version}`}:{},n=new i({baseUrl:t,retry:e?.retry,headers:{authorization:`Bearer ${s}`,...a},cache:e?.cache===!1?void 0:e?.cache||"no-store",signal:e?.signal});super(n)}static fromEnv(s,t){let r=s?.UPSTASH_VECTOR_REST_URL||process?.env.UPSTASH_VECTOR_REST_URL,a=s?.UPSTASH_VECTOR_REST_TOKEN||process?.env.UPSTASH_VECTOR_REST_TOKEN;if(!r)throw Error("Unable to find environment variable: `UPSTASH_VECTOR_REST_URL`");if(!a)throw Error("Unable to find environment variable: `UPSTASH_VECTOR_REST_TOKEN`");return new e({...t,url:r,token:a})}}}};