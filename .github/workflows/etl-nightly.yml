name: nightly-etl

on:
  schedule:
    - cron: '0 1 * * *'  # 01:00 UTC
  workflow_dispatch: {}

jobs:
  etl:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Set overall job timeout
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - name: Install dependencies
        run: |
          npm ci
      - name: Build application
        run: |
          npm run build
      - name: Start Next.js server and run ETL
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DB_REGISTRY: ${{ secrets.NOTION_DB_REGISTRY }}
          NOTION_DB_CASES: ${{ secrets.NOTION_DB_CASES }}
          NOTION_DB_PUBLISHING: ${{ secrets.NOTION_DB_PUBLISHING }}
          NOTION_DB_FINANCE: ${{ secrets.NOTION_DB_FINANCE }}
          PG_DSN: ${{ secrets.PG_DSN }}
          S3_ENDPOINT: ${{ secrets.S3_ENDPOINT }}
          S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
          S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
          S3_BUCKET: traceremove-content
          QDRANT_URL: ${{ secrets.QDRANT_URL }}
          UPSTASH_VECTOR_REST_URL: ${{ secrets.UPSTASH_VECTOR_REST_URL }}
          UPSTASH_VECTOR_REST_TOKEN: ${{ secrets.UPSTASH_VECTOR_REST_TOKEN }}
          EMBEDDINGS_MODEL: text-embedding-3-large
          PUBLIC_MODE: 'true'
          FULL_SCAN: '1'
          PORT: 3000
          NODE_ENV: production
        run: |
          set -e  # Exit on any error
          
          # Start the Next.js server in the background
          echo "üöÄ Starting Next.js server..."
          npm start &
          SERVER_PID=$!
          
          # Function to cleanup server
          cleanup() {
            echo "üßπ Cleaning up server (PID: $SERVER_PID)..."
            kill $SERVER_PID 2>/dev/null || true
            wait $SERVER_PID 2>/dev/null || true
          }
          trap cleanup EXIT
          
          # Enhanced server readiness check with exponential backoff
          echo "‚è≥ Waiting for server to start..."
          MAX_ATTEMPTS=60  # Increased from 30
          ATTEMPT=1
          WAIT_TIME=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if curl -s --max-time 5 http://localhost:3000/api/system/health > /dev/null; then
              echo "‚úÖ Server is ready (attempt $ATTEMPT)"
              break
            fi
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå Server failed to start within $((MAX_ATTEMPTS * WAIT_TIME)) seconds total"
              echo "üìä Server process status:"
              ps aux | grep -E "(next|node)" || echo "No Next.js processes found"
              echo "üìã Server logs (last 50 lines):"
              # Check for any server output or errors
              sleep 2
              exit 1
            fi
            
            echo "‚è≥ Attempt $ATTEMPT/$MAX_ATTEMPTS - waiting ${WAIT_TIME}s..."
            sleep $WAIT_TIME
            
            # Exponential backoff with max cap
            if [ $WAIT_TIME -lt 4 ]; then
              WAIT_TIME=$((WAIT_TIME + 1))
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          # Additional health check to ensure all services are ready
          echo "üîç Running comprehensive health check..."
          HEALTH_RESPONSE=$(curl -s --max-time 10 "http://localhost:3000/api/system/health?detailed=true" || echo "")
          
          if [ -z "$HEALTH_RESPONSE" ]; then
            echo "‚ùå Health check endpoint not responding"
            exit 1
          fi
          
          echo "üìä Health check results:"
          echo "$HEALTH_RESPONSE" | jq '.' || echo "$HEALTH_RESPONSE"
          
          # Check if any services are unhealthy
          UNHEALTHY_COUNT=$(echo "$HEALTH_RESPONSE" | jq '.unhealthy // 0' 2>/dev/null || echo "0")
          if [ "$UNHEALTHY_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è Warning: $UNHEALTHY_COUNT unhealthy services detected, but proceeding with ETL"
          fi
          
          # Run the ETL with enhanced error handling
          echo "üöÄ Running full ETL sync..."
          
          # Use timeout to prevent hanging
          timeout 1200 curl -s -w "%{http_code}" -o /tmp/etl_response.json \
            --max-time 1200 \
            --retry 2 \
            --retry-delay 30 \
            --retry-max-time 180 \
            http://localhost:3000/api/etl/full || ETL_EXIT_CODE=$?
          
          ETL_HTTP_CODE=$(cat /tmp/etl_response.json | tail -n1 2>/dev/null || echo "000")
          ETL_RESPONSE=$(cat /tmp/etl_response.json 2>/dev/null || echo "{}")
          
          echo "üìä ETL Response Code: $ETL_HTTP_CODE"
          echo "üìÑ ETL Response:"
          echo "$ETL_RESPONSE" | jq '.' 2>/dev/null || echo "$ETL_RESPONSE"
          
          # Evaluate results
          if [ "$ETL_HTTP_CODE" = "200" ]; then
            echo "‚úÖ ETL completed successfully"
          elif [ "$ETL_HTTP_CODE" = "206" ]; then
            echo "‚ö†Ô∏è ETL completed with partial success"
            # Extract details about failed databases
            FAILED_DBS=$(echo "$ETL_RESPONSE" | jq -r '.results._summary.failedDatabases // 0' 2>/dev/null || echo "0")
            SUCCESSFUL_DBS=$(echo "$ETL_RESPONSE" | jq -r '.results._summary.successfulDatabases // 0' 2>/dev/null || echo "0")
            echo "üìä Results: $SUCCESSFUL_DBS successful, $FAILED_DBS failed databases"
          else
            echo "‚ùå ETL failed with HTTP $ETL_HTTP_CODE"
            
            # Extract error details for debugging
            ERROR_TYPE=$(echo "$ETL_RESPONSE" | jq -r '.errorType // "unknown"' 2>/dev/null || echo "unknown")
            ERROR_MSG=$(echo "$ETL_RESPONSE" | jq -r '.error // "Unknown error"' 2>/dev/null || echo "Unknown error")
            
            echo "üîç Error Type: $ERROR_TYPE"
            echo "üìù Error Message: $ERROR_MSG"
            
            # Don't fail for certain recoverable errors in partial success scenarios
            if [ "$ETL_HTTP_CODE" = "503" ] && echo "$ERROR_TYPE" | grep -q "configuration\|database"; then
              echo "‚ö†Ô∏è Configuration or database issue detected - this may be transient"
            fi
            
            exit 1
          fi
